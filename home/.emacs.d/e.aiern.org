#+setupfile: ./README.org
#+include: ./README.org

This is used to hold larger files for =./oreo.aiern.org=.

* lib
** simple+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220542751717900

#+name: 20210601220542751717900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; simple+.el --- Extensions to standard library `simple.el'.
;;
;; Filename: simple+.el
;; Description: Extensions to standard library `simple.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
;; Created: Fri Apr 12 10:56:45 1996
;; Version: 0
;; Package-Requires: ((strings "0"))
;;; Last-Updated: Mon Jul 29 13:20:05 2019 (-0700)
;;           By: dradams
;;     Update #: 505
;; URL: https://www.emacswiki.org/emacs/download/simple%2b.el
;; Keywords: internal, lisp, extensions, abbrev
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `misc-fns', `strings', `thingatpt', `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to standard library `simple.el'.
;;
;;  See also library `icicles.el' for extensions to `simple.el' that
;;  concern input completion in the minibuffer.  Those extensions used
;;  to be in this library, but they are used by `icicles.el', so they
;;  have been moved there.
;;
;;  Things you might want to do:
;;
;;  * Turn on `hl-line-mode' in compilation and grep buffers:
;;
;;    (add-hook 'next-error-hook 'next-error-buffer-hl-line)
;;
;;  * Change the fringe indicator for `next-error':
;;
;;    (add-hook 'next-error-hook 'next-error-fringe-setup)
;;
;;
;;  Commands defined here:
;;
;;    `set-any-variable'.
;;
;;  Non-interactive functions defined here:
;;
;;    `next-error-buffer-hl-line', `next-error-fringe-setup',
;;    `read-var-and-value'.
;;
;;  Internal variables defined here:
;;
;;    `next-error-fringe-indicator', `set-any-variable-value-history'.
;;
;;
;;  ***** NOTE: The following user options defined in `simple.el' have
;;              been REDEFINED HERE:
;;
;;    `next-error-highlight', `next-error-highlight-no-select'
;;                            - New value: `until-move' (persistent).
;;
;;
;;  ***** NOTE: The following functions defined in `simple.el' have
;;              been REDEFINED HERE:
;;
;;    `edit-and-eval-command' - Bug fix for < Emacs 21: Adds COMMAND
;;                              as a command to `command-history', not
;;                              as a string.
;;
;;    `kill-new'              - Bug fix for < Emacs 21: be sure
;;                              `kill-ring' is non-empty before trying
;;                              to replace kill.
;;
;;    `next-error'            - `C-u C-u' just deletes highlighting
;;
;;  ***** NOTE: This EMACS PRIMITIVE has been REDEFINED HERE:
;;
;;    `set-variable' - Uses `read-var-and-value' to get args.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2015/06/16 dadams
;;     Added: next-error-buffer-hl-line, next-error-fringe-setup,
;;            next-error-fringe-indicator.
;; 2015/06/13 dadams
;;     next-error: next-error-recenter is not defined for Emacs 22, so use boundp.
;; 2012/02/03 dadams
;;     read-var-and-value:
;;       Added optional arg BUFFER.  Use default-value if var is not local.
;;     set(-any)-variable:
;;       Add BUFFER arg in call to read-var-and-value (only for Icicles).
;;       Set default value, if not MAKE-LOCAL.
;; 2011/05/16 dadams
;;     Added redefinition of kill-new for Emacs 20.
;; 2011/01/04 dadams
;;     Added autoload cookie for command set-any-variable.
;; 2009-02-22 dadams
;;     Added: next-error(-highlight(-no-select)).
;; 2006/09/15 dadams
;;     set-variable: Protect custom-variable-p if not defined.
;; 2006/08/03 dadams
;;     No longer initialize kill-ring to ("") - no longer needed, and can cause problems.
;; 2005-10-31 dadams
;;     Added: set-any-variable-value-history, read-var-and-value, set*-variable.
;; 2005/10/03 dadams
;;     Removed require of icomplete+.el (no longer redefines read-from-minibuffer).
;; 2005/07/28 dadams
;;     Moved all completion stuff to icicles.el:
;;       choose-completion-string, completion-setup-function, switch-to-completions.
;;     No longer require icicles.el.
;;     Removed: completion-reference-buffer.
;;     completion-setup-function:
;;       Renamed icicle-completing-read-prompt-suffix to icicle-prompt-suffix.
;; 2005/07/15 dadams
;;     choose-completion-string, completion-setup-function: Updated for Emacs 21+.
;; 2005/07/10 dadams
;;     Renamed: command-calling-for-completion -> icicle-cmd-calling-for-completion.
;; 2004/09/21 dadams
;;     Only redefine edit-and-eval-command & choose-completion-string if prior to Emacs 21.
;; 1999/03/17 dadams
;;     1. choose-completion-string: Added doc string.  Updated to correspond to
;;        Emacs 34.1 version.
;;     2. completion-setup-function: diff prompt setups.  face1 & face2 tests.
;;     3. Added: switch-to-completions.
;; 1996/06/14 dadams
;;     kill-ring: Bug fix: `mouse-save-then-kill' expects a consp, so ensure this.
;; 1996/04/26 dadams
;;     Put escaped newlines on long-line strings.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

;; Cannot do (require 'simple), because `simple.el' does no `provide'.
;; Don't want to do a (load-library "simple") either, because it wouldn't
;; allow doing (eval-after-load "simple" '(require 'simple+))

(eval-when-compile (when (< emacs-major-version 21) (require 'cl-lib))) ;; push, pop

(require 'strings) ;; read-any-variable

(when (< emacs-major-version 22)        ; Quiet the byte-compiler.
  (defvar compilation-highlight-overlay)
  (defvar fringe-indicator-alist)
  (defvar next-error-function)
  (defvar next-error-last-buffer)
  (defvar next-error-recenter))

;;;;;;;;;;;;;;;;;;;;



;; REPLACE ORIGINAL in `simple.el'.
;;
;; Added new value `until-move'.  It is used in `compile+.el'.
;;
(when (> emacs-major-version 21)
  (defcustom next-error-highlight 0.5
    "*Highlighting of the current locus in selected source buffer.
Highlighting means use face `next-error' or show a fringe arrow.
Value:
,* `fringe-arrow' means indicate the locus using a fringe arrow (which
  is moved when the locus is moved).
,* `until-move' means highlight the locus until it is moved.
,* A number means highlight the locus for that many seconds, or until
  the next command is executed.
,* t means highlight the locus until it is moved or the next command is
  executed.
,* nil means do not highlight the locus at all."
    :type '(choice
            (number :tag "Highlight locus for specified time")
            (const :tag  "Highlight locus until move"                 until-move)
            (const :tag  "Highlight locus until move or next command" t)
            (const :tag  "Do not highlight locus"                     nil)
            (const :tag  "Indicate locus using fringe arrow"          fringe-arrow))
    :group 'next-error
    :version "22.1"))



;; REPLACE ORIGINAL in `simple.el'.
;;
;; Added new value `until-move'.  It is used in `compile+.el'.
;;
(when (> emacs-major-version 21)
  (defcustom next-error-highlight-no-select 0.5
    "*Highlighting of locations in `next-error-no-select'.
Highlighting means use face `next-error' or show a fringe arrow.
Value:
,* `fringe-arrow' means indicate the locus using a fringe arrow (which
  is moved when the locus is moved)..
,* `until-move' means highlight the locus until it is moved.
,* A number means highlight the locus for that many seconds, or until
  the next command is executed.
,* t means highlight the locus until it is moved or the next command is
  executed.
,* nil means do not highlight the locus at all."
    :type '(choice
            (number :tag "Highlight locus for specified time")
            (const :tag  "Highlight locus until move"                 until-move)
            (const :tag  "Highlight locus until move or next command" t)
            (const :tag  "Do not highlight locus"                     nil)
            (const :tag  "Indicate locus using fringe arrow"          fringe-arrow))
    :group 'next-error
    :version "22.1"))



;; REPLACE ORIGINAL in `simple.el'.
;;
;; `C-u C-u' means delete the highlight overlay.
;;
(when (> emacs-major-version 21)
  (defun next-error (&optional arg reset)
    "Visit next `next-error' message and corresponding source code.
If all the error messages parsed so far have been processed already,
the message buffer is checked for new ones.

A numeric prefix ARG specifies how many error messages to move;
 negative means move back to previous error messages.
Plain `\\[universal-argument]' means reparse the error message buffer and start at the
first error.
`C-u C-u' means just delete the highlight overlay (if any).

The RESET argument specifies that we should restart from the beginning.

`\\[next-error]' normally uses the most recently started
compilation, grep, or occur buffer.  It can also operate on any
buffer with output from the \\[compile], \\[grep] commands, or,
more generally, on any buffer in Compilation mode or with
Compilation Minor mode enabled, or any buffer in which
`next-error-function' is bound to an appropriate function.
To specify use of a particular buffer for error messages, type
`\\[next-error]' in that buffer when it is the only one displayed
in the current frame.

Once `\\[next-error]' has chosen the buffer for error messages, it
runs `next-error-hook' with `run-hooks', and stays with that buffer
until you use it in some other buffer which uses Compilation mode
or Compilation Minor mode.

See variables `compilation-parse-errors-function' and
\`compilation-error-regexp-alist' for customization ideas."
    (interactive "P")
    (if (and (consp arg) (= 16 (prefix-numeric-value arg))
             (boundp 'compilation-highlight-overlay)
             compilation-highlight-overlay)
        (delete-overlay compilation-highlight-overlay)
      (when (consp arg) (setq reset  t
                              arg    nil))
      (when (setq next-error-last-buffer  (next-error-find-buffer))
        ;; we know here that next-error-function is a valid symbol we can funcall
        (with-current-buffer next-error-last-buffer
          (funcall next-error-function (prefix-numeric-value arg) reset)
          (when (and (boundp 'next-error-recenter)  next-error-recenter)
            (recenter next-error-recenter))
          (run-hooks 'next-error-hook))))))

;; Indicating the current error in the compilation/grep buffer.

(when (fboundp 'hl-line-mode)

  (defun next-error-buffer-hl-line ()
    "Turn on `hl-line-mode' in buffer `next-error-last-buffer'.
To turn it off: `M-x hl-line-mode' in the compilation/grep buffer."
    (when (and next-error-last-buffer  (buffer-live-p next-error-last-buffer))
      (with-current-buffer next-error-last-buffer
        (hl-line-mode 1)))))

  ;; (add-hook 'next-error-hook 'next-error-buffer-hl-line)



(when (> emacs-major-version 21)

  (defvar next-error-fringe-indicator 'filled-rectangle
    "Fringe indicator to use for `next-error' in compilation/grep buffer.
The indicator is set to the value of `next-error-fringe-indicator'.")

  (defun next-error-fringe-setup ()
    "Set the fringe indicator for `next-error' in compilation/grep buffer."
    (with-current-buffer next-error-last-buffer
      (unless (eq next-error-fringe-indicator
                  (cdr (assq 'overlay-arrow fringe-indicator-alist)))
        (setq fringe-indicator-alist
              (cons `(overlay-arrow . ,next-error-fringe-indicator)
                    fringe-indicator-alist))))))

  ;; (add-hook 'next-error-hook 'next-error-fringe-setup)





;; REPLACE ORIGINAL in `simple.el'.
;;
;; Original was bugged: it added COMMAND as a string to
;; `command-history'.  This version adds it as a command.
;; This was fixed in Emacs 21.
;;
(when (< emacs-major-version 21)
  (defun edit-and-eval-command (prompt command)
    "Prompting with PROMPT, let user edit COMMAND and eval result.
COMMAND is a Lisp expression.  Let user edit that expression in
the minibuffer, then read and evaluate the result."
    (let* ((minibuffer-history-sexp-flag  t)
           (command                       (read-from-minibuffer
                                           prompt (prin1-to-string command)
                                           read-expression-map t '(command-history . 1))))
      ;; If command was added to `command-history' as a string,
      ;; get rid of that.  We want only evaluable expressions there.
      (when (stringp (car command-history)) (pop command-history))
      ;; If command to be redone does not match front of `command-history',
      ;; add it to `command-history'.
      (unless (equal command (car command-history)) (push command command-history))
      (eval command))))


(defvar set-any-variable-value-history nil
  "History of values entered with `set-any-variable'.")


;; Helper function for `set*-variable'.
;; Inspired from original `set-variable', with these changes:
;; Use READ-VAR-FN and SET-VAR-HIST-VAR.  Use current value as default value.
;;
(defun read-var-and-value (read-var-fn set-var-hist-var make-local-p &optional buffer)
  "Read a variable name and value.
READ-VAR-FN is a function to read the variable name.
SET-VAR-HIST-VAR is a variable holding a history of variable values.
MAKE-LOCAL-P non-nil means the variable is to be local.
Optional arg BUFFER is the buffer used to determine the current value
of the variable, which is used as the default value when reading the new value."
  (let* ((var                   (funcall read-var-fn "Set variable: "))
         (current-val           (format "%S"
                                        (if (fboundp 'buffer-local-value) ; Emacs 22+.
                                            (buffer-local-value var (or buffer
                                                                        (current-buffer)))
                                          (if (member var (buffer-local-variables buffer))
                                              (with-current-buffer (or buffer
                                                                       (current-buffer))
                                                (symbol-value var))
                                            (default-value var)))))
         (minibuffer-help-form  '(describe-variable var))
         (prompt                (format "Set %s%s to value: " var
                                        (cond ((local-variable-p var) " (buffer-local)")
                                              ((or make-local-p
                                                   (local-variable-if-set-p var))
                                               " buffer-locally")
                                              (t " globally"))))
         (prop                  (get var 'variable-interactive))
         (val                   (if prop
                                    ;; Use VAR's `variable-interactive' property
                                    ;; as an interactive spec for prompting.
                                    (call-interactively `(lambda (arg)
                                                          (interactive ,prop) arg))
                                  (read (read-string prompt current-val set-var-hist-var
                                                     current-val)))))
    (list var val make-local-p)))



;; REPLACE ORIGINAL (built-in).
;;
;; Uses `read-var-and-value' to get args interactively.
;;
;;;###autoload
(defun set-variable (variable value &optional make-local)
  "Set VARIABLE to VALUE.  VALUE is a Lisp object.
Enter VALUE in Lisp syntax.  For example, if you want VALUE to be a
string then you must surround it with double-quote chars.  VALUE is
used literally, not evaluated.

If VARIABLE has a `variable-interactive' property then that is used as
if it were the arg to `interactive', to interactively read VALUE.

If VARIABLE was defined with `defcustom' then the type information in
the definition is used to check that VALUE is valid.  But this
function does not pay attention to any `:set' property the variable
might have (if you want that, use \\[customize-set-variable] instead).

With a prefix argument, set VARIABLE to VALUE buffer-locally."
  (interactive (read-var-and-value 'read-variable
                                   'set-variable-value-history
                                   current-prefix-arg
                                   (and (boundp 'icicle-pre-minibuffer-buffer)
                                        icicle-mode
                                        icicle-pre-minibuffer-buffer)))
  (and (or (not (fboundp 'custom-variable-p)) (custom-variable-p variable))
       (not (get variable 'custom-type))
       (custom-load-symbol variable))
  (let ((type  (get variable 'custom-type)))
    (when type
      ;; Match with custom type.
      (require 'cus-edit)
      (setq type  (widget-convert type))
      (unless (widget-apply type :match value)
        (error "Value `%S' does not match type %S of %S" value (car type) variable))))
  (if make-local
      (set (make-local-variable variable) value)
    (set-default variable value))
  ;; Force a thorough redisplay for the case that the variable
  ;; has an effect on the display, like `tab-width' has.
  (force-mode-line-update))

;;;###autoload
(defun set-any-variable (variable value &optional make-local)
  "Set VARIABLE to VALUE.  VALUE is a Lisp object.
VARIABLE can be any Lisp variable, unlike `set-variable', where it
must be a user option.  Enter VALUE in Lisp syntax.  For example, if
you want VALUE to be a string then you must surround it with
double-quote chars.  VALUE is used literally, not evaluated.

If VARIABLE has a `variable-interactive' property then that is used as
if it were the arg to `interactive', to interactively read VALUE.

If VARIABLE was defined with `defcustom' then the type information in
the definition is used to check that VALUE is valid.  But this
function does not pay attention to any `:set' property the variable
might have (if you want that, use \\[customize-set-variable] instead).

With a prefix argument, set VARIABLE to VALUE buffer-locally."
  (interactive (read-var-and-value 'read-any-variable
                                   'set-any-variable-value-history
                                   current-prefix-arg
                                   (and (boundp 'icicle-pre-minibuffer-buffer)
                                        icicle-mode
                                        icicle-pre-minibuffer-buffer)))
  (and (custom-variable-p variable)
       (not (get variable 'custom-type))
       (custom-load-symbol variable))
  (let ((type  (get variable 'custom-type)))
    (when type
      ;; Match with custom type.
      (require 'cus-edit)
      (setq type  (widget-convert type))
      (unless (widget-apply type :match value)
        (error "Value `%S' does not match type %S of %S" value (car type) variable))))
  (if make-local
      (set (make-local-variable variable) value)
    (set-default variable value))
  ;; Force a thorough redisplay for the case that the variable
  ;; has an effect on the display, like `tab-width' has.
  (force-mode-line-update))



;; REPLACE ORIGINAL in `simple.el'.
;;
;; Just updates 20.3 with version from 20.6.1: corrects deletion of multiple.
;;
(when (string< emacs-version "20.6.1")
  (defun comment-region (beg end &optional arg)
    "Comment or uncomment each line in the region.
With just C-u prefix arg, uncomment each line in region.
Numeric prefix arg ARG means use ARG comment characters.
If ARG is negative, delete that many comment characters instead.
Comments are terminated on each line, even for syntax in which newline does
not end the comment.  Blank lines do not get comments."
    ;; if someone wants it to only put a comment-start at the beginning and
    ;; comment-end at the end then typing it, C-x C-x, closing it, C-x C-x
    ;; is easy enough.  No option is made here for other than commenting
    ;; every line.
    (interactive "r\nP")
    (or comment-start (error "No comment syntax is defined"))
    (when (> beg end) (let (mid)
                        (setq mid  beg
                              beg  end
                              end  mid)))
    (save-excursion
      (save-restriction
        (let ((cs  comment-start)
              (ce  comment-end)
              (cp  (and comment-padding (make-string comment-padding ?)))
              numarg)
          (if (consp arg)
              (setq numarg  t)
            (setq numarg  (prefix-numeric-value arg))
            ;; For positive arg > 1, replicate the comment delims now,
            ;; then insert the replicated strings just once.
            (while (> numarg 1)
              (setq cs      (concat cs comment-start)
                    ce      (concat ce comment-end)
                    numarg  (1- numarg))))
          ;; cl-loop over all lines from BEG to END.
          (narrow-to-region beg end)
          (goto-char beg)
          (if (or (eq numarg t) (< numarg 0))
              (while (not (eobp))
                (let (found-comment)
                  ;; Delete comment start from beginning of line.
                  (if (eq numarg t)
                      (while (looking-at (regexp-quote cs))
                        (setq found-comment  t)
                        (delete-char (length cs)))
                    (let ((count  numarg))
                      (while (and (> 1 (setq count  (1+ count)))
                                  (looking-at (regexp-quote cs)))
                        (setq found-comment  t)
                        (delete-char (length cs)))))
                  ;; Delete comment padding from beginning of line
                  (when (and found-comment comment-padding (looking-at (regexp-quote cp)))
                    (delete-char comment-padding))
                  ;; Delete comment end from end of line.
                  (if (string= "" ce)
                      nil
                    (if (eq numarg t)
                        (progn
                          (end-of-line)
                          ;; This is questionable if comment-end ends in
                          ;; whitespace.  That is pretty brain-damaged,
                          ;; though.
                          (while (progn (skip-chars-backward " \t")
                                        (and (>= (- (point) (point-min)) (length ce))
                                             (save-excursion
                                               (backward-char (length ce))
                                               (looking-at (regexp-quote ce)))))
                            (delete-char (- (length ce)))))
                      (let ((count  numarg))
                        (while (> 1 (setq count  (1+ count)))
                          (end-of-line)
                          ;; this is questionable if comment-end ends in whitespace
                          ;; that is pretty brain-damaged though
                          (skip-chars-backward " \t")
                          (if (>= (- (point) (point-min)) (length ce))
                              (save-excursion
                                (backward-char (length ce))
                                (if (looking-at (regexp-quote ce))
                                    (delete-char (length ce)))))))))
                  (forward-line 1)))

            (when comment-padding (setq cs  (concat cs cp)))
            (while (not (eobp))
              ;; Insert at beginning and at end.
              (if (looking-at "[ \t]*$") ()
                (insert cs)
                (if (string= "" ce) ()
                  (end-of-line)
                  (insert ce)))
              (search-forward "\n" nil 'move))))))))



;; REPLACE ORIGINAL in `simple.el'.
;;
;; Fixes bug when REPLACE is non-nil but `kill-ring' is nil.
;;
(when (< emacs-major-version 21)
  (defun kill-new (string &optional replace)
    "Make STRING the latest kill in the kill ring.
Set the kill-ring-yank pointer to point to it.
If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list."
    (and (fboundp 'menu-bar-update-yank-menu)
         (menu-bar-update-yank-menu string (and replace (car kill-ring))))
    (if (and replace kill-ring)         ; Bug fix: only if non-nil `kill-ring'.
        (setcar kill-ring string)
      (setq kill-ring  (cons string kill-ring))
      (when (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
    (setq kill-ring-yank-pointer  kill-ring)
    (when interprogram-cut-function
      (funcall interprogram-cut-function string (not replace)))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'simple+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; simple+.el ends here
#+end_src

** window+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220546246471000

#+name: 20210601220546246471000
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; window+.el --- Extensions to `window.el'.
;;
;; Filename: window+.el
;; Description: Extensions to `window.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
;; Created: Thu Jan 25 14:22:13 1996
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 16:24:31 2018 (-0800)
;;           By: dradams
;;     Update #: 219
;; URL: https://www.emacswiki.org/emacs/download/window%2b.el
;; Doc URL: https://emacswiki.org/emacs/Delete_Frames_Easily_-_But_Not_Too_Easily
;; Doc URL: https://www.emacswiki.org/emacs/OneOnOneEmacs
;; Keywords: internal, window
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `window.el'.
;;
;;
;;  ***** NOTE: The following functions defined in `window.el' have
;;              been REDEFINED HERE:
;;
;;  `count-windows' -
;;     Only use arg MINIBUF if current frame has a minibuffer.
;;
;;  `special-display-popup-frame' (Emacs 24+) - Fit the frame.
;;
;;  `quit-window' - Call `delete-window' inside `condition-case'.
;;
;;  This file should be loaded after loading the standard GNU file
;;  `window.el'.  So, in your `~/.emacs' file, do this:
;;  (eval-after-load "window" '(require 'window+))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2014/10/25 dadams
;;     special-display-popup-frame: Protect set-window-prev-buffers with fboundp.
;; 2014/02/16 dadams
;;     special-display-popup-frame:
;;       Use vanilla Emacs 24 code for display-buffer-record-window,
;;       set-window-buffer, etc.  Fixes Emacs bug #16768.
;; 2012/10/15 dadams
;;     Do not redefine quit-window for Emacs 24+, so do not delete frame for NEWS.
;;       Thx to Martin Rudalics.
;; 2012/09/10 dadams
;;     special-display-popup-frame: Protect fit-frame call with fboundp.
;; 2012/08/31 dadams
;;     special-display-popup-frame:
;;       save-selected-window -> save-window-excursion -
;;         fixes bug that moved point to bob when use pp-eval-last-sexp.
;; 2012/08/25 dadams
;;     special-display-popup-frame:
;;       Put back missing (set-window-buffer window buffer) - removed accidentally.
;;       Call fit-frame with the buffer's WINDOW selected.  Inhibit before then.
;; 2012/08/11 dadams
;;     special-display-popup-frame:
;;       Adapt redefinition for all Emacs versions.
;;       Do not raise or fit frame if (car ARGS) is a FUNCTION.  Make it do the work.
;; 2012/08/10 dadams
;;     special-display-popup-frame: Updated for latest Emacs 24.
;; 2011/06/29 dadams
;;     Added: special-display-popup-frame (for Emacs 24+).
;;     Require fit-frame.el (for Emacs 24+).
;; 2011/01/04 dadams
;;     Added autoload cookie for command quit-window.
;; 2008/02/27 dadams
;;     Added redefinition of quit-window.
;; 1996/01/25 dadams
;;     count-windows: Returned to original meaning of arg,
;;                    but only use arg ifframe has a minibuffer.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

 ;; Cannot do (require 'window), because `window.el' does no `provide'.
 ;; Don't want to do a (load-library "window") either, because it wouldn't
 ;; allow doing (eval-after-load "window" '(progn (require 'window+)))

(when (> emacs-major-version 23)
  (require 'fit-frame nil t)) ;; (no error if not found): fit-frame

;;;;;;;;;;;;;;;;;;;;;;;;;;


;; REPLACE ORIGINAL in `window.el':
;;
;; 1. Only use arg MINIBUF if current frame has a minibuffer.
;;
;; 2. Corrected doc string:
;;    Original doc string indicated opposite behavior for arg MINIBUF.
;;
(defun count-windows (&optional minibuf)
  "Return the number of visible windows in selected frame.
Optional arg MINIBUF is used only if selected frame has a minibuffer.

MINIBUF = t means count the minibuffer window even if *not* active.
MINIBUF = nil or omitted means count the minibuffer iff it is active.
If MINIBUF is neither t nor nil it means not to count the minibuffer
even if it is active.  (See function `walk-windows'.)"
  (let ((count 0))
    (walk-windows (function (lambda (w) (setq count (+ count 1))))
                  (and (memq (cdr (assoc 'minibuffer (frame-parameters)))
                             '(only t)) ; If this frame has a minibuffer,
                       minibuf))        ; pass the arg.  (Else pass nil.)
    count))


;; REPLACE ORIGINAL in `window.el' (in `frame.el' prior to Emacs 24).
;;
;; 1. (Emacs 20 only) Call `make-frame' while BUFFER is current, so that
;;    any frame hooks (e.g. `after-make-frame-functions') will use BUFFER,
;;    not the previously current buffer.
;;
;; 2. Call `fit-frame', with BUFFER's window selected.  Inhibit fitting before then.
;;
;; NOTE: The same definition is in `frame+.el'.  If this is changed, update that too.
;;
(defun special-display-popup-frame (buffer &optional args)
  "Pop up a frame displaying BUFFER.  Return its window.
If BUFFER is already displayed in a visible or iconified frame then
raise that frame.  Otherwise, display BUFFER in a new frame.

Optional argument ARGS is a list specifying additional information.

If ARGS is an alist, use it as a list of frame parameters.  If these
parameters contain (same-window . t) then display BUFFER in the
selected window.  If they contain (same-frame . t) then display BUFFER
in a window of the selected frame.

If ARGS is a list whose car is a symbol then use (car ARGS) as a
function to do the work: display the buffer and raise its frame.  Pass
it BUFFER as first argument, and (cdr ARGS) as the rest of the
arguments."
  (if (and args (symbolp (car args)))
;;;   Should we let/make the FUNCTION that is (car ARGS) do everything, or should we
;;;   ensure that the frame is fit and raised?  For now, make FUNCTION do everything.
;;;   (let* ((window  (apply (car args) buffer (cdr args)))
;;;          (frame   (window-frame window)))
;;;     (when (fboundp 'fit-frame) (fit-frame (window-frame window)))
;;;     (raise-frame frame)
;;;     window)                         ; Return the window.
      (apply (car args) buffer (cdr args))
    (let ((window  (get-buffer-window buffer 0)))
      (or
       ;; If we have a window already, make it visible.
       (and window
            (let ((frame  (window-frame window)))
              (make-frame-visible frame)
              (raise-frame frame)
              (when (fboundp 'display-buffer-record-window) ; Emacs 24+
                (display-buffer-record-window 'reuse window buffer))
              (when (fboundp 'fit-frame) (fit-frame frame))
              window))                  ; Return the window.
       ;; Reuse the selected window if the caller requested it.
       (and (cdr (assq 'same-window args))
            (condition-case nil         ; Try Emacs 24 `switch-to-buffer' first.
                (progn (switch-to-buffer buffer nil t) (selected-window))
              (error                    ; Try again, with old `switch-to-buffer'.
               (condition-case nil
                   (progn (switch-to-buffer buffer) (selected-window))
                 (error nil)))))
       ;; Stay on the same frame if requested.
       (and (or (cdr (assq 'same-frame args))  (cdr (assq 'same-window args)))
            (let ((pop-up-windows                t)
                  (pop-up-frames                 nil)
                  (special-display-buffer-names  ())
                  (special-display-regexps       ()))
              (display-buffer buffer)))
       ;; If no window yet, make one in a new frame.
       ;; `make-frame' creates the frame before the buffer is shown in it, so do not
       ;; call `fit-frame' until we can select the buffer's window.
       (let* ((make-frame-functions  (delq 'fit-frame after-make-frame-functions))
              (frame                 (with-current-buffer buffer
                                       (make-frame
                                        (append args special-display-frame-alist))))
              (window                (frame-selected-window frame)))
         (when (fboundp 'display-buffer-record-window) ; Emacs 24+
           (display-buffer-record-window 'frame window buffer))
        (unless (eq buffer (window-buffer window))
            (set-window-buffer window buffer)
            (when (fboundp 'set-window-prev-buffers) ; Emacs 24+
              (set-window-prev-buffers window ())))
        (set-window-dedicated-p window t)
                ;; Now call `fit-frame', with WINDOW selected.
                ;; Needs to be `save-window-excursion', not just `save-selected-window'.
        (when (fboundp 'fit-frame)
          (save-window-excursion (select-window window) (fit-frame)))
        window)))))                    ; Return the window.


;; REPLACE ORIGINAL in `window.el':
;;
;; Do not avoid calling `delete-window', even if `one-window-p'.
;; Instead, wrap the call in `condition-case'.
;; This way, if you use my version of `delete-window' (defined in
;; `frame-cmds.el'), then the frame is also deleted if `one-window-p'.
;; Not needed (and not appropriate) for Emacs 24.
;;
(when (< emacs-major-version 24)
  (defun quit-window (&optional kill window)
    "Quit the current buffer.  Bury it, and maybe delete the selected frame.
\(The frame is deleted if it contains a dedicated window for the buffer.)
With a prefix argument, kill the buffer instead.

Noninteractively, if KILL is non-nil, then kill the current buffer,
otherwise bury it.

If WINDOW is non-nil, it specifies a window; we delete that window,
and the buffer that is killed or buried is the one in that window."
    (interactive "P")
    (let ((buffer (window-buffer window))
          (frame (window-frame (or window (selected-window))))
          (window-solitary
           (save-selected-window
             (if window
                 (select-window window))
             (one-window-p t)))
          window-handled)

      (save-selected-window
        (if window
            (select-window window))
        (or (window-minibuffer-p)
            (window-dedicated-p (selected-window))
            (switch-to-buffer (other-buffer))))

      ;; Get rid of the frame, if it has just one dedicated window
      ;; and other visible frames exist.
      (and (or (window-minibuffer-p) (window-dedicated-p window))
           (delq frame (visible-frame-list))
           window-solitary
           (if (and (eq default-minibuffer-frame frame)
                    (= 1 (length (minibuffer-frame-list))))
               (setq window nil)
             (delete-frame frame)
             (setq window-handled t)))

      ;; Deal with the buffer.
      (if kill
          (kill-buffer buffer)
        (bury-buffer buffer))

      ;; Maybe get rid of the window.
      (unless window-handled
        (condition-case nil
            (delete-window window)
          (error nil))))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'window+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; window+.el ends here
#+end_src

** dired-details.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220552477105500

#+name: 20210601220552477105500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; dired-details.el --- make file details hide-able in dired

;; Copyright (C) 2003-2011 Rob Giardina

;; Version: 1.3.2
;; Keywords: dired, hide
;; Author: Rob Giardina <rob.giardina.ohmmanepadmespam@oracle.com>
;; Maintainer: Rob Giardina
;; Last updated: Aug 17, 2012
;; Contributors: Harold Maier, Klaus Berndl

;; This file is not part of GNU Emacs.

;; This is free software; you can redistribute it and/or modify it
;; under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
;; License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:

;; `dired-details-hide' makes dired buffers that look like this:
;;
;;  /private/rgiardin/lispHome:
;;  used 1264 available files
;;
;;  drwxr-xr-x   5 rgiardin g632         512 Jan 19  2003 ..
;;  -rw-r--r--   1 rgiardin svrtech     4141 Aug 23 17:07 dired-details.el
;;  -rw-r--r--   1 rgiardin svrtech     4141 Aug 23 17:07 my-really-really-long-I-mean-really-long-filename.el
;;  -rw-r--r--   1 rgiardin svrtech       56 Aug 23 17:07 linked-file.el -> /var/tmp/checkouts/linked-file.el
;;
;; look like this:
;;
;;  /private/rgiardin/lispHome/emacs.config:
;;  used 1264 available files
;;
;;  [...] ..
;;  [...] dired-details.el
;;  [...] my-really-really-long-I-mean-really-long-filename.el
;;  [...] linked-file.el -> [...]
;;
;; The function `dired-details-toggle' will toggle details on and off.
;;
;;
;; INSTALLATION:
;;
;; To apply `dired-details-hide' to all new dired buffers, add the
;; following to your .emacs:
;;
;; (require 'dired-details)
;; (dired-details-install)
;;
;; This also binds the following keys in dired buffers:
;;
;;   ) - dired-details-show
;;   ( - dired-details-hide
;;
;; CHANGES:
;;
;; * 1.3.2: Added sr-mode to dired-details-hide function to make it word with
;;          Sunrise Commander
;; * 1.3.1: Allow "misc lines (total used, find-dired statuses, etc)" to be hidden;
;;          suggested by Chris Poole
;; * 1.3: dired-details-toggle and customization support added by Klaus Berndl
;; * 1.2.4: Setup hide and show keybindings earlier than the first hide.
;; * 1.2.3: add dired-details-initially-hide customization as suggested by Harold Maier
;; * 1.2.2: extensive change to support subdirs in dired buffers
;; * 1.2.1: respect current hidden state (not initial state) when inserting subdirs
;;
;; TODO:
;; * add a hook for dired-add-file to hide new entries as necessary
;;

;;; customizable vars

(defgroup dired-details nil
  "Settings for the dired-details package."
  :group 'dired
  :prefix "dired-details-")

(defcustom dired-details-hidden-string "[...]"
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-hide-link-targets t
  "*Hide symbolic link target paths."
  :group 'dired-details
  :type 'boolean)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)

(defcustom dired-details-hide-extra-lines t
  "*Hides lines matching any regex in `dired-details-invisible-lines'.
Changing this variable will not affect existing dired buffers."
  :group 'dired-details
  :type 'boolean)

(defcustom dired-details-invisible-lines
  '("total used in directory" "^\\s-*$" "find finished" "find \\." "  wildcard ")
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'list)

;;; implementation

(defvar dired-details-debug nil)

(defvar dired-details-internal-overlay-list nil)
(make-variable-buffer-local 'dired-details-internal-overlay-list)

(defvar dired-details-state nil
  "Three possible values: nil (has not been set), 'hidden (details are
hidden), 'shown (details are visible).")
(make-variable-buffer-local 'dired-details-state)

(defun dired-details-install ()
  (eval-after-load "dired"
    '(progn
       (add-hook 'dired-after-readin-hook 'dired-details-activate)

       (define-key dired-mode-map "(" 'dired-details-hide)
       (define-key dired-mode-map ")" 'dired-details-show)

       (defadvice dired-revert (before remember-the-details activate)
         (dired-details-delete-overlays)))))

(defun dired-details-activate ()
  "Set up dired-details in the current dired buffer. Called by
dired-after-readin-hook on initial display and when a subdirectory is
inserted (with `i')."
  ;;if a state has been chosen in this buffer, respect it
  (if dired-details-state
    (when (eq 'hidden dired-details-state)
      (dired-details-hide))
    ;;otherwise, use the default state
    (when dired-details-initially-hide
      (dired-details-hide))))

(defun dired-details-delete-overlays ()
  (mapc '(lambda (list) (mapc 'delete-overlay
                             (cdr list)))
        dired-details-internal-overlay-list)
  (setq dired-details-internal-overlay-list nil))

(defun dired-details-toggle ( &optional arg default-too )
  "Toggle visibility of dired details.
With positive prefix argument ARG hide the details, with negative
show them."
  (interactive "P")
  (let ((hide (if (null arg)
                (not (eq 'hidden dired-details-state))
                (> (prefix-numeric-value arg) 0))))
    (if default-too
      (setq dired-details-initially-hide hide))
    (if hide (dired-details-hide)
        (dired-details-show))))

(defun dired-details-hide ()
  "Make an invisible, evaporable overlay for each file-line's details
in this dired buffer."
  (interactive)
  (unless (memq major-mode '(dired-mode vc-dired-mode sr-mode))
    (error "dired-details-hide can only be called in dired mode"))

  (when dired-details-debug
    (let ((b (get-buffer-create "dired-details-debug")))
      (append-to-buffer b (point) (point-max))))

  ;;NOTE - we call this even if we're already hidden. There may be a
  ;;new subdirectory inserted that we have to deal with. Pre-existing
  ;;subdirectories will reuse their cached overlays.
  (save-excursion
    (save-restriction
      (widen)
      ;;hide each displayed subdirectory
      (mapc
       '(lambda (dir-and-pos)
          (let ((cached-overlays (assoc (car dir-and-pos)
                                        dired-details-internal-overlay-list)))
            (if cached-overlays
              ;;reuse the existing overlays
              (dired-details-frob-overlays t)
              ;;no existing overlays for this subdir, make 'em
              (let ((cache (list (car dir-and-pos)))
                    (subdir-start (cdr dir-and-pos))
                    (subdir-end (1- (dired-get-subdir-max dir-and-pos))))
                (goto-char subdir-start)
                (forward-line 1) ;;always skip the dir line
                ;;v1.3 (dired-goto-next-file)
                (while (< (point) subdir-end)
                  (dired-details-make-current-line-overlay cache)
                  (forward-line 1))
                  ;;v1.3 (dired-next-line 1))
                (setq dired-details-internal-overlay-list
                      (cons cache dired-details-internal-overlay-list))))))
       dired-subdir-alist)))
  (setq dired-details-state 'hidden))

(defun dired-details-show ()
  "Show whatever details a call to `dired-details-hide' may have
hidden in this buffer."
  (interactive)
  (dired-details-frob-overlays nil)
  (setq dired-details-state 'shown))

(defun dired-details-make-current-line-overlay ( cache )
  (let* ((bol (progn (beginning-of-line) (point)))
         (totally-hide nil)
         (details              ;hide flags, size, owner, date, etc.
          (cond ((ignore-errors (dired-move-to-filename t))
                 (make-overlay (+ 2 bol) (point)))
                ((and dired-details-hide-extra-lines
                      (let ((line (buffer-substring (point-at-bol) (point-at-eol))))
                        (when (delq nil (mapcar (lambda (x) (string-match x line))
                                                dired-details-invisible-lines))
                          (let ((o (make-overlay bol (1+ (point-at-eol)))))
                            ;;this is delayed so that the hide-link bit below doesn't bork
                            (overlay-put o 'make-intangible t)
                            (overlay-put o 'suppress-before t)
                            o)))))))
         (ln-target            ;hide symlink dest
          (when dired-details-hide-link-targets
            (if (progn (beginning-of-line)
                       (search-forward-regexp
                        "-> \\(.*\\)"
                        (save-excursion (end-of-line) (point)) t))
              (make-overlay (match-beginning 1) (match-end 1))))))
    
    (when details
      (overlay-put details 'evaporate t)
      (dired-details-hide-overlay details)

      (when ln-target
        (overlay-put ln-target 'evaporate t)
        (dired-details-hide-overlay ln-target))

      (setcdr cache (append (if ln-target
                              (list ln-target details)
                              (list details))
                            (cdr cache))))))

(defun dired-details-hide-overlay (o)
  (overlay-put o 'invisible t)
  (if (overlay-get o 'make-intangible) (overlay-put o 'intangible t))
  (unless (overlay-get o 'suppress-before)
    (overlay-put o 'before-string dired-details-hidden-string)))

(defun dired-details-show-overlay (o)
  (overlay-put o 'invisible nil)
  (overlay-put o 'before-string nil))

(defun dired-details-frob-overlays ( hide )
  (if dired-details-internal-overlay-list
    (mapc '(lambda (list)
             (mapc (if hide 'dired-details-hide-overlay 'dired-details-show-overlay)
                   (cdr list)))
          dired-details-internal-overlay-list)))

(provide 'dired-details)

;;; dired-details.el ends here
#+end_src

** fringe.el

#+call: hash() :exports none

#+name: 
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; fringe.el --- fringe setup and control  -*- coding: utf-8 -*-

;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008,
;;   2009 Free Software Foundation, Inc.

;; Author: Simon Josefsson <simon@josefsson.org>
;; Maintainer: FSF
;; Keywords: frames

;; This file is part of GNU Emacs.

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This file contains code to initialize the built-in fringe bitmaps
;; as well as helpful functions for customizing the appearance of the
;; fringe.

;; The code is influenced by scroll-bar.el and avoid.el.  The author
;; gratefully acknowledge comments and suggestions made by Miles
;; Bader, Eli Zaretski, Richard Stallman, Pavel JanÃ­k and others which
;; improved this package.

;;; Code:

(defgroup fringe nil
  "Window fringes."
  :version "22.1"
  :group 'frames)

;; Define the built-in fringe bitmaps and setup default mappings

(when (boundp 'fringe-bitmaps)
  (let ((bitmaps '(question-mark
		   left-arrow right-arrow up-arrow down-arrow
		   left-curly-arrow right-curly-arrow
		   left-triangle right-triangle
		   top-left-angle top-right-angle
		   bottom-left-angle bottom-right-angle
		   left-bracket right-bracket
		   filled-rectangle hollow-rectangle
		   filled-square hollow-square
		   vertical-bar horizontal-bar
		   empty-line))
	(bn 1))
    (while bitmaps
      (push (car bitmaps) fringe-bitmaps)
      (put (car bitmaps) 'fringe bn)
      (setq bitmaps (cdr bitmaps)
	    bn (1+ bn))))

  (setq-default fringe-indicator-alist
		'((truncation . (left-arrow right-arrow))
		  (continuation . (left-curly-arrow right-curly-arrow))
		  (overlay-arrow . right-triangle)
		  (up . up-arrow)
		  (down . down-arrow)
		  (top . (top-left-angle top-right-angle))
		  (bottom . (bottom-left-angle bottom-right-angle
			     top-right-angle top-left-angle))
		  (top-bottom . (left-bracket right-bracket
				 top-right-angle top-left-angle))
		  (empty-line . empty-line)
		  (unknown . question-mark)))

  (setq-default fringe-cursor-alist
		'((box . filled-rectangle)
		  (hollow . hollow-rectangle)
		  (bar . vertical-bar)
		  (hbar . horizontal-bar)
		  (hollow-small . hollow-square))))


(defmacro fringe-bitmap-p (symbol)
  "Return non-nil if SYMBOL is a fringe bitmap."
  `(get ,symbol 'fringe))


;; Control presence of fringes

(defvar fringe-mode)

(defvar fringe-mode-explicit nil
  "Non-nil means `set-fringe-mode' should really do something.
This is nil while loading `fringe.el', and t afterward.")

(defun set-fringe-mode-1 (ignore value)
  "Call `set-fringe-mode' with VALUE.
See `fringe-mode' for valid values and their effect.
This is usually invoked when setting `fringe-mode' via customize."
  (set-fringe-mode value))

(defun set-fringe-mode (value)
  "Set `fringe-mode' to VALUE and put the new value into effect.
See `fringe-mode' for possible values and their effect."
  (setq fringe-mode value)

  (when fringe-mode-explicit
    (modify-all-frames-parameters
     (list (cons 'left-fringe (if (consp fringe-mode)
				  (car fringe-mode)
				fringe-mode))
	   (cons 'right-fringe (if (consp fringe-mode)
				   (cdr fringe-mode)
				 fringe-mode))))))

;; For initialization of fringe-mode, take account of changes
;; made explicitly to default-frame-alist.
(defun fringe-mode-initialize (symbol value)
  (let* ((left-pair (assq 'left-fringe default-frame-alist))
	 (right-pair (assq 'right-fringe default-frame-alist))
	 (left (cdr left-pair))
	 (right (cdr right-pair)))
    (if (or left-pair right-pair)
	;; If there's something in default-frame-alist for fringes,
	;; don't change it, but reflect that into the value of fringe-mode.
	(progn
	  (setq fringe-mode (cons left right))
	  (if (equal fringe-mode '(nil . nil))
	      (setq fringe-mode nil))
	  (if (equal fringe-mode '(0 . 0))
	      (setq fringe-mode 0)))
      ;; Otherwise impose the user-specified value of fringe-mode.
      (custom-initialize-reset symbol value))))

(defcustom fringe-mode nil
  "Specify appearance of fringes on all frames.
This variable can be nil (the default) meaning the fringes should have
the default width (8 pixels), it can be an integer value specifying
the width of both left and right fringe (where 0 means no fringe), or
a cons cell where car indicates width of left fringe and cdr indicates
width of right fringe (where again 0 can be used to indicate no
fringe).
To set this variable in a Lisp program, use `set-fringe-mode' to make
it take real effect.
Setting the variable with a customization buffer also takes effect.
If you only want to modify the appearance of the fringe in one frame,
you can use the interactive function `set-fringe-style'."
  :type '(choice (const :tag "Default width" nil)
		 (const :tag "No fringes" 0)
		 (const :tag "Only right" (0 . nil))
		 (const :tag "Only left" (nil . 0))
		 (const :tag "Half width" (5 . 5))
		 (const :tag "Minimal" (1 . 1))
		 (integer :tag "Specific width")
		 (cons :tag "Different left/right sizes"
		       (integer :tag "Left width")
		       (integer :tag "Right width")))
  :group 'fringe
  :require 'fringe
  :initialize 'fringe-mode-initialize
  :set 'set-fringe-mode-1)

;; We just set fringe-mode, but that was the default.
;; If it is set again, that is for real.
(setq fringe-mode-explicit t)

(defun fringe-query-style (&optional all-frames)
  "Query user for fringe style.
Returns values suitable for left-fringe and right-fringe frame parameters.
If ALL-FRAMES, the negation of the fringe values in
`default-frame-alist' is used when user enters the empty string.
Otherwise the negation of the fringe value in the currently selected
frame parameter is used."
  (let ((mode (intern (completing-read
		       (concat
			"Select fringe mode for "
			(if all-frames "all frames" "selected frame")
			" (type ? for list): ")
		       '(("none") ("default") ("left-only")
			 ("right-only") ("half") ("minimal"))
		       nil t))))
    (cond ((eq mode 'none) 0)
	  ((eq mode 'default) nil)
	  ((eq mode 'left-only) '(nil . 0))
	  ((eq mode 'right-only) '(0 . nil))
	  ((eq mode 'half) '(5 . 5))
	  ((eq mode 'minimal) '(1 . 1))
	  ((eq mode (intern ""))
	   (if (eq 0 (cdr (assq 'left-fringe
				(if all-frames
				    default-frame-alist
				  (frame-parameters (selected-frame))))))
	       nil
	     0)))))

(defun fringe-mode (&optional mode)
  "Set the default appearance of fringes on all frames.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  This command applies to all
frames that exist and frames to be created in the future.  If you
want to set the default appearance of fringes on the selected
frame only, see the command `set-fringe-style'."
  (interactive (list (fringe-query-style 'all-frames)))
  (set-fringe-mode mode))

(defun set-fringe-style (&optional mode)
  "Set the default appearance of fringes on the selected frame.

When called interactively, query the user for MODE.  Valid values
for MODE include `none', `default', `left-only', `right-only',
`minimal' and `half'.

When used in a Lisp program, MODE can be a cons cell where the
integer in car specifies the left fringe width and the integer in
cdr specifies the right fringe width.  MODE can also be a single
integer that specifies both the left and the right fringe width.
If a fringe width specification is nil, that means to use the
default width (8 pixels).  This command may round up the left and
right width specifications to ensure that their sum is a multiple
of the character width of a frame.  It never rounds up a fringe
width of 0.

Fringe widths set by `set-window-fringes' override the default
fringe widths set by this command.  If you want to set the
default appearance of fringes on all frames, see the command
`fringe-mode'."
  (interactive (list (fringe-query-style)))
  (modify-frame-parameters
   (selected-frame)
   (list (cons 'left-fringe (if (consp mode) (car mode) mode))
	 (cons 'right-fringe (if (consp mode) (cdr mode) mode)))))

(defsubst fringe-columns (side &optional real)
  "Return the width, measured in columns, of the fringe area on SIDE.
If optional argument REAL is non-nil, return a real floating point
number instead of a rounded integer value.
SIDE must be the symbol `left' or `right'."
  (funcall (if real '/ 'ceiling)
	   (or (funcall (if (eq side 'left) 'car 'cadr)
			(window-fringes))
	       0)
           (float (frame-char-width))))

(provide 'fringe)

;; arch-tag: 6611ef60-0869-47ed-8b93-587ee7d3ff5d
;;; fringe.el ends here
#+end_src